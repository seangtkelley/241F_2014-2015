#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    colorKnob,      sensorPotentiometer)
#pragma config(Sensor, in3,    positionKnob,   sensorPotentiometer)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftArm,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           rightArm,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           frontRight,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           backLeft,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port7,           backRight,     tmotorVex393, openLoop, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port8,           strafe,        tmotorVex393, openLoop, encoder, encoderPort, I2C_5, 1000)
#pragma config(Motor,  port9,           rightVacuum,   tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port10,          leftVacuum,    tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"


void forward(float inches);
void backward(float inches);
void rotateLeft(float ticks);
void rotateRight(float ticks);
void strafeLeft(float inches);
void strafeRight(float inches);
void lowHeight();
void mediumHeight();
void highHeight();
void spinF();
void spinB();
void spinS();

const float TICKS_PER_INCH = 28.6487;

const int FORWARD = 0;
const int BACKWARD = 1;
const int R_RIGHT = 2;
const int R_LEFT = 3;
const int S_RIGHT = 4;
const int S_LEFT = 5;
const int LOWHEIGHT = 6;
const int MEDIUMHEIGHT = 7;
const int HIGHHEIGHT = 8;
const int speed = 100;
const int COAST = 500;
const int SPINF = 7;
const int SPINB = 8;
const int SPINS = 9;

bool rightRedPosition = true;
bool leftRedPosition = true;
bool rightBluePosition = false;
bool leftBluePosition = true;

bool isHigh = false;
bool isMedium = false;
bool isLow = true;

/*
int rightRedCommands[][2] = {{FORWARD, .5},
															{BACKWARD, .5}};
int leftRedCommands[][2] = {{FORWARD, .5},
															{BACKWARD, .5}};

int rightBlueCommands[][2] = {{SPINF, 0},
												 {FORWARD, .5},
												 {BACKWARD, .5},
												 {SPINS, 0}};

int leftBlueCommands[][2] = {{SPINF, 0},
												 {FORWARD, .5},
												 {BACKWARD, .5},
												 {SPINS, 0}};
*/


void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){

	if(SensorValue[colorKnob] < 40){
		if(SensorValue[positionKnob] < 40){
			rightBluePosition = true;
		}else{
			leftBluePosition = true;
		}
	}else{
		if(SensorValue[positionKnob] < 40){
			rightRedPosition = true;
		}else{
			leftRedPosition = true;
		}
	}

	int i = 0;

	if(rightBluePosition){
  	/*for(i = 0; i < sizeof(rightBlueCommands); i++){
			if(rightBlueCommands[i][0] == R_RIGHT)
      	rotateRight(rightBlueCommands[i][1]);
    	else if(rightBlueCommands[i][0] == R_LEFT)
      	rotateLeft(rightBlueCommands[i][1]);
     	else if(rightBlueCommands[i][0] == S_RIGHT)
      	strafeLeft(rightBlueCommands[i][1]);
     	else if(rightBlueCommands[i][0] == S_LEFT)
      	strafeLeft(rightBlueCommands[i][1]);
    	else if(rightBlueCommands[i][0] == LOWHEIGHT)
      	lowHeight();
    	else if(rightBlueCommands[i][0] == MEDIUMHEIGHT)
      	mediumHeight();
    	else if(rightBlueCommands[i][0] == HIGHHEIGHT)
    		highHeight();
    	else if(rightBlueCommands[i][0] == SPINF)
      	spinF();
    	else if(rightBlueCommands[i][0] == SPINB)
      	spinB();
    	else if(rightBlueCommands[i][0] == SPINS)
    		spinS();
    	else if(rightBlueCommands[i][0] == FORWARD)
      	forward(rightBlueCommands[i][1]);
    	else if(rightBlueCommands[i][0] == BACKWARD)
    		backward(rightBlueCommands[i][1]);
    	wait1Msec(100);
  	}*/
	}else if(leftBluePosition){
  	/*for(i = 0; i < 11; i++){
			if(leftBlueCommands[i][0] == R_RIGHT)
      	rotateRight(leftBlueCommands[i][1]);
    	else if(leftBlueCommands[i][0] == R_LEFT)
      	rotateLeft(leftBlueCommands[i][1]);
     	else if(leftBlueCommands[i][0] == S_RIGHT)
      	strafeLeft(leftBlueCommands[i][1]);
     	else if(rightBlueCommands[i][0] == S_LEFT)
      	strafeLeft(rightBlueCommands[i][1]);
    	else if(leftBlueCommands[i][0] == LOWHEIGHT)
      	lowHeight();
    	else if(leftBlueCommands[i][0] == MEDIUMHEIGHT)
      	mediumHeight();
    	else if(leftBlueCommands[i][0] == HIGHHEIGHT)
    		highHeight();
    	else if(leftBlueCommands[i][0] == SPINF)
      	spinF();
    	else if(leftBlueCommands[i][0] == SPINB)
      	spinB();
    	else if(leftBlueCommands[i][0] == SPINS)
    		spinS();
    	else if(leftBlueCommands[i][0] == FORWARD)
      	forward(leftBlueCommands[i][1]);
    	else if(leftBlueCommands[i][0] == BACKWARD)
    		backward(leftBlueCommands[i][1]);
    	wait1Msec(100);
  	}*/
  }else if(rightRedPosition){
  	/*for(i = 0; i < 11; i++){
			if(rightRedCommands[i][0] == R_RIGHT)
      	rotateRight(rightRedCommands[i][1]);
    	else if(rightRedCommands[i][0] == R_LEFT)
      	rotateLeft(rightRedCommands[i][1]);
     	else if(rightRedCommands[i][0] == S_RIGHT)
      	strafeLeft(rightRedCommands[i][1]);
     	else if(rightRedCommands[i][0] == S_LEFT)
      	strafeLeft(rightRedCommands[i][1]);
    	else if(rightRedCommands[i][0] == LOWHEIGHT)
     		lowHeight();
    	else if(rightRedCommands[i][0] == MEDIUMHEIGHT)
     		mediumHeight();
    	else if(rightRedCommands[i][0] == HIGHHEIGHT)
    		highHeight();
    	else if(rightRedCommands[i][0] == SPINF)
      	spinF();
    	else if(rightRedCommands[i][0] == SPINB)
      	spinB();
    	else if(rightRedCommands[i][0] == SPINS)
    		spinS();
    	else if(rightRedCommands[i][0] == FORWARD)
      	forward(rightRedCommands[i][1]);
    	else if(rightRedCommands[i][0] == BACKWARD)
    		backward(rightRedCommands[i][1]);
    	wait1Msec(100);
  	}*/
  }else if(leftRedPosition){
  	/*for(i = 0; i < 11; i++){
			if(leftRedCommands[i][0] == R_RIGHT)
      	rotateRight(leftRedCommands[i][1]);
    	else if(leftRedCommands[i][0] == R_LEFT)
      	rotateLeft(leftRedCommands[i][1]);
     	else if(leftRedCommands[i][0] == S_RIGHT)
     		strafeLeft(leftRedCommands[i][1]);
     	else if(leftRedCommands[i][0] == S_LEFT)
      	strafeLeft(leftRedCommands[i][1]);
    	else if(leftRedCommands[i][0] == LOWHEIGHT)
      	lowHeight();
    	else if(leftRedCommands[i][0] == MEDIUMHEIGHT)
      	mediumHeight();
    	else if(leftRedCommands[i][0] == HIGHHEIGHT)
    		highHeight();
    	else if(leftRedCommands[i][0] == SPINF)
      	spinF();
    	else if(leftRedCommands[i][0] == SPINB)
      	spinB();
    	else if(leftRedCommands[i][0] == SPINS)
    		spinS();
    	else if(leftRedCommands[i][0] == FORWARD)
      	forward(leftRedCommands[i][1]);
    	else if(leftRedCommands[i][0] == BACKWARD)
    		backward(leftRedCommands[i][1]);
    	wait1Msec(100);
  	}*/
	}

}

task usercontrol(){

	while (true){

  	if(bVEXNETActive){

  		/*if(vexRT[Ch2Xmtr2] > 0){
  			if(vexRT[Ch4Xmtr2] < 0){
  				motor[backRight] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[backLeft] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[frontRight] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[frontLeft] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
  			}else if(vexRT[Ch4Xmtr2] > 0){
  				motor[backRight] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[backLeft] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[frontRight] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[frontLeft] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
  			}
  		} else if(vexRT[Ch2Xmtr2] < 0) {
  			if(vexRT[Ch4Xmtr2] > 0){
  				motor[backRight] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[backLeft] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[frontRight] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[frontLeft] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
  			}else if(vexRT[Ch4Xmtr2] < 0){
  				motor[backRight] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[backLeft] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
    			motor[frontRight] = vexRT[Ch2Xmtr2] + abs(vexRT[Ch4Xmtr2]);
    			motor[frontLeft] = vexRT[Ch2Xmtr2] - abs(vexRT[Ch4Xmtr2]);
  			}
  		} else {
  			motor[backRight] = 0;
    		motor[backLeft] = 0;
    		motor[frontRight] = 0;
    		motor[frontLeft] = 0;
  		}

  		motor[strafe] = vexRT[Ch1Xmtr2];*/

  		if(vexRT[Ch2] > 5){
  			int x = vexRT[Ch2];
  			int y = vexRT[Ch2];
  			if(vexRT[Ch1] < -5){
  				x = vexRT[Ch2] - abs(vexRT[Ch1]);
    			y = vexRT[Ch2] + abs(vexRT[Ch1]);
    			/*motor[frontRight] = vexRT[Ch2] + abs(vexRT[Ch4]);
    			motor[frontLeft] = vexRT[Ch2] - abs(vexRT[Ch4]);*/
  			}else if(vexRT[Ch1] > 5){
  				x = motor[backRight] = vexRT[Ch2] + abs(vexRT[Ch1]);
    			y = motor[backLeft] = vexRT[Ch2] - abs(vexRT[Ch1]);
    			/*motor[frontRight] = vexRT[Ch2] - abs(vexRT[Ch4]);
    			motor[frontLeft] = vexRT[Ch2] + abs(vexRT[Ch4]);*/
  			}

  			motor[backRight] = x;
  			motor[backLeft] = y;
  		} else if(vexRT[Ch2] < -5) {
  			int x = vexRT[Ch2];
  			int y = vexRT[Ch2];
  			if(vexRT[Ch1] > 5){
  				x = vexRT[Ch2] + abs(vexRT[Ch1]);
    			y = vexRT[Ch2] - abs(vexRT[Ch1]);
    			/*motor[frontRight] = vexRT[Ch2] - abs(vexRT[Ch4]);
    			motor[frontLeft] = vexRT[Ch2] + abs(vexRT[Ch4]);*/
  			}else if(vexRT[Ch1] < -5){
  				x = vexRT[Ch2] - abs(vexRT[Ch1]);
    			y = vexRT[Ch2] + abs(vexRT[Ch1]);
    			/*motor[frontRight] = vexRT[Ch2] + abs(vexRT[Ch4]);
    			motor[frontLeft] = vexRT[Ch2] - abs(vexRT[Ch4]);*/
  			}

  			motor[backRight] = x;
  			motor[backLeft] = y;
  		} else {
  			motor[backRight] = 0;
    		motor[backLeft] = 0;
    		motor[frontRight] = 0;
    		motor[frontLeft] = 0;
  		}

  		motor[strafe] = vexRT[Ch4];

    	if(vexRT[Btn7D] == true){
      	 motor[rightVacuum] = 127;
      	 motor[leftVacuum] = 127;
    	}else if(vexRT[Btn7U] == true){
      	 motor[leftVacuum] = -127;
      	 motor[rightVacuum] = -127;
    	}else{
      	motor[rightVacuum] = 0;
      	motor[leftVacuum] = 0;
    	}

    	nMotorEncoder[leftArm] = 0;
    	nMotorEncoder[rightArm] = 0;

    	if(vexRT[Btn8U] == true){
      	if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        	motor[rightArm] = 127/2;
        	motor[leftArm] = 127;
      	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        	motor[rightArm] = 127;
        	motor[leftArm] = 127/2;
      	}else{
        	motor[rightArm] = 127;
        	motor[leftArm] = 127;
      	}

    	}else if(vexRT[Btn8D] == true){
      	if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        	motor[rightArm] = -10;
        	motor[leftArm] = -20;
      	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        	motor[rightArm] = -20;
        	motor[leftArm] = -10;
      	}else{
        	motor[rightArm] = -20;
        	motor[leftArm] = -20;
      	}

    	}else{
      	motor[rightArm] = 0;
      	motor[leftArm] = 0;
    	}

    	wait10Msec(1);

  	}
	}
}

void spinF(){
  motor[rightVacuum] = 127;
  motor[leftVacuum] = 127;
  wait1Msec(500);
}
void spinB(){
  motor[rightVacuum] = -127;
  motor[leftVacuum] = -127;
  wait1Msec(500);
}
void spinS(){
  motor[rightVacuum] = 0;
  motor[leftVacuum] = 0;
  wait1Msec(500);
}

void forward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
		motor[frontRight] = speed;
  	motor[backRight] = speed;
  	motor[frontLeft] = speed;
  	motor[backLeft] = speed;
	}

  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;

}

void backward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
		motor[frontRight] = -speed;
  	motor[backRight] = -speed;
  	motor[frontLeft] = -speed;
  	motor[backLeft] = -speed;
	}

  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;

}

void rotateLeft(float ticks){

 	nMotorEncoder[backLeft] = 0;
 	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[frontRight] = -speed;
  	motor[backRight] = -speed;
  	motor[frontLeft] = speed;
  	motor[backLeft] = speed;
	}

  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;

}

void rotateRight(float ticks){

 	nMotorEncoder[backLeft] = 0;
 	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[frontRight] = speed;
  	motor[backRight] = speed;
  	motor[frontLeft] = -speed;
  	motor[backLeft] = -speed;
	}

  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;

}

void strafeRight(float inches){

	nMotorEncoder[strafe] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[strafe]) <= targetTicks){
		motor[strafe] = speed;
	}

  motor[strafe] = 0;

}

void strafeLeft(float inches){

  nMotorEncoder[strafe] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[strafe]) <= targetTicks){
		motor[strafe] = -speed;
	}

  motor[strafe] = 0;

}

void highHeight(){

  if(isLow){
  	isHigh = true;
  	isMedium = false;
  	isLow = false;

  	float ticks = 2000;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}

}

void mediumHeight(){
	if(isLow){
		isHigh = false;
  	isMedium = true;
  	isLow = false;

  	float ticks = 1600;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}
}

void lowHeight(){

	motor[rightArm] = -127;
  motor[leftArm] = -127;

  wait1Msec(250);

  motor[rightArm] = 0;
  motor[leftArm] = 0;

}
