#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    colorKnob,      sensorPotentiometer)
#pragma config(Sensor, in3,    positionKnob,   sensorPotentiometer)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftArm,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           rightArm,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           right,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           left,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           rightVacuum,   tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port7,           leftVacuum,    tmotorVex269, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard!!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"


void forward(float inches);
void backward(float inches);
void rotateLeft(float ticks);
void rotateRight(float ticks);
void lowHeight();
void mediumHeight();
void highHeight();
void spinF();
void spinB();
void spinS();

const float TICKS_PER_INCH = 28.6487;

const int speed = 100;

bool rightRedPosition = true;
bool leftRedPosition = true;
bool rightBluePosition = false;
bool leftBluePosition = true;

bool isHigh = false;
bool isMedium = false;
bool isLow = true;

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){

	if(SensorValue[colorKnob] < 40){
		if(SensorValue[positionKnob] < 40){
			rightBluePosition = true;
		}else{
			leftBluePosition = true;
		}
	}else{
		if(SensorValue[positionKnob] < 40){
			rightRedPosition = true;
		}else{
			leftRedPosition = true;
		}
	}

	if(rightBluePosition){

	}else if(leftBluePosition){

  }else if(rightRedPosition){

  }else if(leftRedPosition){

	}
}

task usercontrol(){

	while (true){

  	if(bVEXNETActive){

  		if(vexRT[Ch2] > 5){
  			int rightVal = vexRT[Ch2];
  			int leftVal = vexRT[Ch2];
  			if(vexRT[Ch1] < -5){
  				rightVal = vexRT[Ch2] - abs(vexRT[Ch1]);
    			leftVal = vexRT[Ch2] + abs(vexRT[Ch1]);
  			}else if(vexRT[Ch1] > 5){
  				rightVal = vexRT[Ch2] + abs(vexRT[Ch1]);
    			leftVal = vexRT[Ch2] - abs(vexRT[Ch1]);
  			}

  			motor[right] = rightVal;
  			motor[left] = leftVal;
  		} else if(vexRT[Ch2] < -5) {
  			int rightVal = vexRT[Ch2];
  			int leftVal = vexRT[Ch2];
  			if(vexRT[Ch1] > 5){
  				rightVal = vexRT[Ch2] + abs(vexRT[Ch1]);
    			leftVal = vexRT[Ch2] - abs(vexRT[Ch1]);
  			}else if(vexRT[Ch1] < -5){
  				rightVal = vexRT[Ch2] - abs(vexRT[Ch1]);
    			leftVal = vexRT[Ch2] + abs(vexRT[Ch1]);
  			}

  			motor[right] = rightVal;
  			motor[left] = leftVal;
  		} else {
  			motor[right] = 0;
    		motor[left] = 0;
  		}

    	if(vexRT[Btn7D] == true){
      	 motor[rightVacuum] = 127;
      	 motor[leftVacuum] = 127;
    	}else if(vexRT[Btn7U] == true){
      	 motor[leftVacuum] = -127;
      	 motor[rightVacuum] = -127;
    	}else{
      	motor[rightVacuum] = 0;
      	motor[leftVacuum] = 0;
    	}

    	nMotorEncoder[leftArm] = 0;
    	nMotorEncoder[rightArm] = 0;

    	if(vexRT[Btn8U] == true){
      	if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        	motor[rightArm] = 127/2;
        	motor[leftArm] = 127;
      	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        	motor[rightArm] = 127;
        	motor[leftArm] = 127/2;
      	}else{
        	motor[rightArm] = 127;
        	motor[leftArm] = 127;
      	}

    	}else if(vexRT[Btn8D] == true){
      	if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        	motor[rightArm] = -10;
        	motor[leftArm] = -20;
      	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        	motor[rightArm] = -20;
        	motor[leftArm] = -10;
      	}else{
        	motor[rightArm] = -20;
        	motor[leftArm] = -20;
      	}

    	}else{
      	motor[rightArm] = 0;
      	motor[leftArm] = 0;
    	}

    	wait10Msec(1);

  	}
	}
}

void spinF(){
  motor[rightVacuum] = 127;
  motor[leftVacuum] = 127;
  wait1Msec(500);
}
void spinB(){
  motor[rightVacuum] = -127;
  motor[leftVacuum] = -127;
  wait1Msec(500);
}
void spinS(){
  motor[rightVacuum] = 0;
  motor[leftVacuum] = 0;
  wait1Msec(500);
}

void forward(float inches){

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[left]) <= targetTicks && abs(nMotorEncoder[right]) <= targetTicks){
		motor[right] = speed;
  	motor[left] = speed;
	}

  motor[right] = 0;
  motor[left] = 0;

}

void backward(float inches){

	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[left]) <= targetTicks && abs(nMotorEncoder[right]) <= targetTicks){
  	motor[right] = -speed;
  	motor[left] = -speed;
	}

  motor[right] = 0;
  motor[left] = 0;

}

void rotateLeft(float ticks){

 	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;

	while(abs(nMotorEncoder[left]) <= ticks && abs(nMotorEncoder[right]) <= ticks){
		motor[right] = -speed;
  	motor[left] = speed;
	}

  motor[right] = 0;
  motor[left] = 0;

}

void rotateRight(float ticks){

 	nMotorEncoder[left] = 0;
	nMotorEncoder[right] = 0;

	while(abs(nMotorEncoder[left]) <= ticks && abs(nMotorEncoder[right]) <= ticks){
		motor[right] = speed;
  	motor[left] = -speed;
	}

  motor[right] = 0;
  motor[left] = 0;

}

void highHeight(){

  if(isLow){
  	isHigh = true;
  	isMedium = false;
  	isLow = false;

  	float ticks = 2000;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}

}

void mediumHeight(){
	if(isLow){
		isHigh = false;
  	isMedium = true;
  	isLow = false;

  	float ticks = 1600;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}
}

void lowHeight(){

	motor[rightArm] = -127;
  motor[leftArm] = -127;

  wait1Msec(250);

  motor[rightArm] = 0;
  motor[leftArm] = 0;

}
