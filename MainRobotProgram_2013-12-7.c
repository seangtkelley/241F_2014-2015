#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    colorKnob,      sensorPotentiometer)
#pragma config(Sensor, in3,    positionKnob,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  autonButton,    sensorTouch)
#pragma config(Sensor, I2C_1,  leftArmEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  rightArmEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  rightDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  leftDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftArm,    tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           rightArm,   tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           frontLeft,      tmotorVex393, openLoop, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port7,           frontRight,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port8,           rightVacuum,   tmotorVex393, openLoop)
#pragma config(Motor,  port9,           leftVacuum,    tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*#pragma config(Motor,  port4,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393, openLoop, reversed)*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"


void driveForward(float inches);
void driveBackward(float inches);
void rotateLeft(float ticks);
void rotateRight(float ticks);
void lowHeight();
void mediumHeight();
void highHeight();
void spinF();
void spinB();
void spinS();


const float TICKS_PER_INCH = 26.3472;

const int speed = 100;

bool rightRedPosition = false;
bool leftRedPosition = false;
bool rightBluePosition = false;
bool leftBluePosition = false;

bool isHigh = false;
bool isMedium = false;
bool isLow = true;

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){
	while(true){
		if(SensorValue(autonButton) == 1){
			if(SensorValue[colorKnob] < 40){
				if(SensorValue[positionKnob] < 40){
					rightBluePosition = true;
					break;
				}else{
					leftBluePosition = true;
					break;
				}
			}else{
				if(SensorValue[positionKnob] < 40){
					rightRedPosition = true;
					break;
				}else{
					leftRedPosition = true;
					break;
				}
			}
			// DELETE THIS
			rightBluePosition = true;
			break;
		}
	}

	if(rightBluePosition){
	  highHeight();
	  driveForward(14);
	  spinB();
	  wait1Msec(500);
	  driveBackward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		driveForward(28);
	  		wait1Msec(500);
	 	 		driveBackward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
	}else if(leftBluePosition){
	  highHeight();
	  driveForward(14);
	  spinB();
	  wait1Msec(500);
	  driveBackward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		driveForward(28);
	  		wait1Msec(500);
	 	 		driveBackward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
  }else if(rightRedPosition){
	  highHeight();
	  driveForward(14);
	  spinB();
	  wait1Msec(500);
	  driveBackward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		driveForward(28);
	  		wait1Msec(500);
	 	 		driveBackward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
  }else if(leftRedPosition){
	  highHeight();
	  driveForward(14);
	  spinB();
	  wait1Msec(500);
	  driveBackward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		driveForward(28);
	  		wait1Msec(500);
	 	 		driveBackward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
	}
}

task usercontrol(){

	while (true){

  	if(bVEXNETActive){

  		motor[backRight] = motor[frontRight] = vexRT[Ch2];
  		motor[backLeft] = motor[frontLeft] = vexRT[Ch3];

    	if(vexRT[Btn5U] == true){
      	 motor[rightVacuum] = 127;
      	 motor[leftVacuum] = 127;
    	}else if(vexRT[Btn5D]== true){
      	 motor[leftVacuum] = -127;
      	 motor[rightVacuum] = -127;
    	}else{
      	motor[rightVacuum] = 0;
      	motor[leftVacuum] = 0;
    	}

    	nMotorEncoder[leftArm] = 0;
    	nMotorEncoder[rightArm] = 0;

    	if(vexRT[Btn6U] == true){

      	if(abs(nMotorEncoder(rightArm)) > abs(nMotorEncoder(leftArm))){
         	motor[rightArm] = 100/2;
         	motor[leftArm] = 100;
      	}else if(abs(nMotorEncoder(rightArm)) < abs(nMotorEncoder(leftArm))){
        	motor[rightArm] = 100;
        	motor[leftArm] = 100/2;
      	}else{
        	motor[rightArm] = 100;
        	motor[leftArm] = 100;
        }

    	}else if(vexRT[Btn6D] == true){

      	if(abs(nMotorEncoder(rightArm)) > abs(nMotorEncoder(leftArm))){
        	motor[rightArm] = -100/2;
         	motor[leftArm] = -100;
        	}else if(abs(nMotorEncoder(rightArm)) < abs(nMotorEncoder(leftArm))){
        	motor[rightArm] = -100;
        	motor[leftArm] = -100/2;
      	}else{
        	motor[rightArm] = -100;
        	motor[leftArm] = -100;
      	}

    	}else{
      	motor[rightArm] = 0;
      	motor[leftArm] = 0;
    	}

    	wait10Msec(1);

  	}
	}
}

void spinF(){
  motor[rightVacuum] = 127;
  motor[leftVacuum] = 127;
  wait1Msec(500);
}
void spinB(){
  motor[rightVacuum] = -127;
  motor[leftVacuum] = -127;
  wait1Msec(500);
}
void spinS(){
  motor[rightVacuum] = 0;
  motor[leftVacuum] = 0;
  wait1Msec(500);
}

void driveForward(float inches){

	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[frontRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches * 4;

	while(abs(nMotorEncoder[frontLeft]) <= targetTicks && abs(nMotorEncoder[frontRight]) <= targetTicks){
		motor[backRight] = speed;
  	motor[backLeft] = speed;
  	motor[frontRight] = speed;
  	motor[frontLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;
  motor[frontRight] = 0;
  motor[frontLeft] = 0;

}

void driveBackward(float inches){

	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[frontRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches * 4;

	while(abs(nMotorEncoder[frontLeft]) <= targetTicks && abs(nMotorEncoder[frontRight]) <= targetTicks){
  	motor[backRight] = -speed;
  	motor[backLeft] = -speed;
  	motor[frontRight] = -speed;
  	motor[frontLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;
  motor[frontRight] = 0;
  motor[frontLeft] = 0;

}

void rotateLeft(float ticks){

 	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[frontRight] = 0;

	while(abs(nMotorEncoder[frontLeft]) <= ticks && abs(nMotorEncoder[frontRight]) <= ticks){
		motor[backRight] = -speed;
  	motor[backLeft] = speed;
  	motor[frontRight] = -speed;
  	motor[frontLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;
  motor[frontRight] = 0;
  motor[frontLeft] = 0;

}

void rotateRight(float ticks){

 	nMotorEncoder[frontLeft] = 0;
	nMotorEncoder[frontRight] = 0;

	while(abs(nMotorEncoder[frontLeft]) <= ticks && abs(nMotorEncoder[frontRight]) <= ticks){
		motor[backRight] = speed;
  	motor[backLeft] = -speed;
  	motor[frontRight] = speed;
  	motor[frontLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;
  motor[frontRight] = 0;
  motor[frontLeft] = 0;

}

void highHeight(){

  if(isLow){
  	isHigh = true;
  	isMedium = false;
  	isLow = false;

  	float ticks = 410;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}

  	motor[rightArm] = 40;
    motor[leftArm] = 40;
	}

}

void mediumHeight(){
	if(isLow){
		isHigh = false;
  	isMedium = true;
  	isLow = false;

  	float ticks = 205;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}
}

void lowHeight(){

	isLow = true;

	motor[rightArm] = -127;
  motor[leftArm] = -127;

  wait1Msec(250);

  motor[rightArm] = 0;
  motor[leftArm] = 0;

}
