#pragma config(Sensor, in1,    lineMiddle,     sensorLineFollower)
#pragma config(Sensor, in2,    lineLeft,       sensorLineFollower)
#pragma config(Sensor, in3,    lineRight,      sensorLineFollower)
#pragma config(Sensor, in4,    lineFarLeft,    sensorLineFollower)
#pragma config(Sensor, in5,    lineFarRight,   sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  ultasonic,      sensorSONAR_cm)
#pragma config(Sensor, dgtl3,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderRight,   sensorQuadEncoder)
#pragma config(Motor,  port1,           FL,            tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,            ,             tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port10,          FR,            tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}







/////////////////////////////////////////////////////////////////////////////////////////
//
//                                  Functions
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
//----------------------------------------------------------------------------------------
//
//                                    INDEX
//
//
//
/////////////////////////////////////////////////////////////////////////////////////////


void drive(bool half)
{

			if (half==false)//Check if drive toggles half speed.
			{
				motor[BR] = vexRT[Ch2]; //give drive direct control.
				motor[FR] = vexRT[Ch2];
				motor[BL] = vexRT[Ch3];
				motor[FL] = vexRT[Ch3];
			}
			else if(half ==true)
			{
				motor[BR] = vexRT[Ch2]/3;//give drive control but all motor maxes are a third of their orignal max.
				motor[FR] = vexRT[Ch2]/3;
				motor[BL] = vexRT[Ch3]/3;
				motor[FL] = vexRT[Ch3]/3;
			}
}


void clearMotor()
{
	motor[FR]=0;
	motor[FL]=0;
	motor[BR]=0;
	motor[BL]=0;
}

void forwardTicks(int ticks)
{
		ticks=ticks;
		SensorValue[encoderLeft]=0;
    while(SensorValue(encoderLeft)<ticks)
    {
      motor[FL]=118;
    	motor[FR]=118;
    	motor[BL]=118;
    	motor[BR]=118;
    }
  motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}

void forwardSeconds(int s)
{
      motor[FL]=118;
    	motor[FR]=118;
    	motor[BL]=118;
    	motor[BR]=118;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}

void backwardTicks(int ticks)
{
		ticks=ticks;
    nMotorEncoder[encoderLeft] = 0;
    int enctick=SensorValue(encoderLeft);
    while(enctick>-ticks)
    {
    motor[FL]=-118;
		motor[FR]=-118;
		motor[BL]=-118;
		motor[BR]=-118;
    }
	motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}


void backwardSeconds(int s)
{
      motor[FL]=-118;
    	motor[FR]=-118;
    	motor[BL]=-118;
    	motor[BR]=-118;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}

/*void turnRightDegrees(float degree)
{
	float first=degree*.8;
	while(abs(SensorValue[gyro]) < first)
	{
      motor[FL]=118;
    	motor[FR]=-118;
    	motor[BL]=118;
    	motor[BR]=-118;
	}
	while(abs(SensorValue[gyro]) < degree)
	{
      motor[FL]=50;
    	motor[FR]=-50;
    	motor[BL]=50;
    	motor[BR]=-50;
	}
      motor[FL]=-5;
    	motor[FR]=5;
    	motor[BL]=-5;
    	motor[BR]=5;
  wait1Msec(250);
  clearMotor();
}




void turnLeftDegrees(float degree)
{
	float first=degree*.8;
	while(abs(SensorValue[gyro]) < first)
	{
      motor[FL]=-118;
    	motor[FR]=118;
    	motor[BL]=-118;
    	motor[BR]=118;
	}
	while(abs(SensorValue[gyro]) < degree)
	{
      motor[FL]=-50;
    	motor[FR]=50;
    	motor[BL]=-50;
    	motor[BR]=50;
	}
      motor[FL]=5;
    	motor[FR]=-5;
    	motor[BL]=5;
    	motor[BR]=-5;
  wait1Msec(250);
  clearMotor();
}



void turnRightTicks(int ticks)
{
	SensorValue[encoderLeft]=0;
	while(SensorValue[encoderLeft]<ticks)
	{
		motor[FL]=118;
		motor[BL]=118;
		motor[FR]=-118;
		motor[BR]=-118;
	}
}


void turnLeftTicks(int ticks)
{
	SensorValue[encoderRight]=0;
	while(SensorValue[encoderRight]<ticks)
	{
		motor[FL]=-118;
		motor[BL]=-118;
		motor[FR]=118;
		motor[BR]=118;
	}
}


void turnRightSeconds(float seconds)
{
	motor[FL]=118;
	motor[BL]=118;
	motor[FR]=-118;
	motor[BR]=-118;
	wait(seconds);
	clearMotor();
}
void turnLeftSeconds(float seconds)
{
	motor[FL]=-118;
	motor[BL]=-118;
	motor[FR]=118;
	motor[BR]=118;
	wait(seconds);
	clearMotor();
}


void raiseArmTicks(int ticks)
{
	while(SensorValue[armp]<ticks)
	{
		motor[leftArm]=118;
		motor[rightArm]=118;
	}
	motor[leftArm]=0;
	motor[rightArm]=0;
}


void raiseArmSeconds(float s)
{
		motor[leftArm]=118;
		motor[rightArm]=118;
		wait(s);
		motor[leftArm]=0;
		motor[rightArm]=0;
}



void lowerArmTicks(int ticks)
{
	while(SensorValue[armp]>ticks)
	{
		motor[leftArm]=-118;
		motor[rightArm]=-118;

	}
	motor[leftArm]=0;
	motor[rightArm]=0;
}



void lowerArmSeconds(float seconds)
{
      motor[leftArm]= -118;
			motor[rightArm]= -118;
   		wait(seconds);
    	motor[leftArm]= -0;
			motor[rightArm]= -0;
}







void raiseIntakeSeconds(float s)
{

	motor[leftintake]=118;
	motor[rightintake]=118;
	wait(s);
	motor[leftintake]=0;
	motor[rightintake]=0;
}


void lowerIntakeSeconds(float s)
{
	motor[leftintake]=118;
	motor[rightintake]=118;
	wait(s);
	motor[leftintake]=0;
	motor[rightintake]=0;
}

void armto(int point)
{
	target=point;
}




task armcontrol()
{
	while(true)
	{
		error=target-SensorValue[armp];
		errorSum+=error;
		motor[leftArm]= error*pGain+errorSum*iGain;
		motor[rightArm]= error*pGain+errorSum*iGain;
	}
}


*/







/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
  // .....................................................................................
  // Insert user code here.
  // .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	bool half=false;
	int buttonToggleState8r = 0;//half speed
  int buttonPressed8r = 0;
	int buttonToggleState7l = 0;//pneumatics
  int buttonPressed7l = 0;

	//startTask(armcontrol);


	while (true)
{


//Toggle half speed---------------------------------------------------------------
		if( vexRT[ Btn7L ] == 1 )
  {
      if( ! buttonPressed7l )
      {
      	// change the toggle state
      	buttonToggleState7l = 1 - buttonToggleState7l;

        // Note the button is pressed
        buttonPressed7l = 1;
      }
  }
  else
  {
	  // the button is not pressed
	   buttonPressed7l = 0;
	}
  // Now do something with our toggle flag
  if( buttonToggleState7l )
  {
      half=true;
  }
  else
  {
      half=false;
	}






//Toggle pneumatics------------------------------------------------
	if( vexRT[ Btn8R ] == 1 )
  {
      if( ! buttonPressed8r )
      {
      	// change the toggle state
      	buttonToggleState8r = 1 - buttonToggleState8r;

        // Note the button is pressed
        buttonPressed8r = 1;
      }
  }
  else
  {
	  // the button is not pressed
	   buttonPressed8r = 0;
	}
  // Now do something with our toggle flag
  if( buttonToggleState8r )
  {
      //SensorValue[pnr]=1;
      //SensorValue[pnl]=1;
  }
  else
  {
     // SensorValue[pnr]=0;
      //SensorValue[pnl]=0;
	}




	//DRIVE-----------------------------------------------------


		drive(half);

		/*motor[leftArm] = 0;
  	motor[rightArm] = 0;
		motor[leftintake] = 0;
  	motor[rightintake] = 0;


  	//ARM MOTION----------------------------


  	while(vexRT[Btn6D] == 1)
		{
			motor[leftArm] = 118;
  		motor[rightArm] = 118;
  		drive(half);
		}

		while(vexRT[Btn5D] == 1)
		{
			motor[leftArm] = -118;
  		motor[rightArm] = -118;
  		drive(half);
		}

		while(vexRT[Btn5U] == 1)
		{
			motor[leftintake] = 118;
  		motor[rightintake] = 118;
  		drive(half);
		}
		while(vexRT[Btn6U] == 1)
		{
			motor[leftintake] = -118;
  		motor[rightintake] = -118;
  		drive(half);
		}*/
	}

}
