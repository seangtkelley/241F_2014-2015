#pragma config(Sensor, in1,    armp,           sensorPotentiometer)
#pragma config(Sensor, in2,    dial,           sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderIntake,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  pnr,            sensorDigitalIn)
#pragma config(Sensor, dgtl8,  pnl,            sensorDigitalIn)
#pragma config(Sensor, dgtl9,  armUltra,       sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armLimit,       sensorTouch)
#pragma config(Motor,  port2,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftintake,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightintake,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#include "functions.c"



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous
//
//
//	1st position: Blue Cube score
//	2nd position: Blue Skyrise score
//	3rd position: Red Cube score
//	4th position: Red Skyrise score
//  5th position: Raise Arm
//
//  **1950 is the height you need to be to retrieve skyrise peices
/////////////////////////////////////////////////////////////////////////////////////////


void autonomous()  //Programs are chosen by the value of the dial potentiometer.
{

		//DO NOT COPY THE TOP!!!

		int position=SensorValue[dial];
		SensorValue(encoderLeft)=0;
		//startTask(armcontrol);
		SensorType[in3]=sensorNone;
		SensorType[in3]=sensorGyro;
//11111111111111111111111111111111111111111111111111111111111111111111111111
//Blue side block || Put block on post turn around grab two and put them somewhere
		if (position>=600&&position<1000)
		{
			backwardSeconds(.33);
			raiseArmSeconds(1);
			lowerIntakeSeconds(1);//Drop Cube on post
			backwardSeconds(.2);
			lowerArmSeconds(1);
			forwardSeconds(.1);
			motor[FR]=118;
			motor[BR]=118;
			wait(.4);
			clearMotor();
			turnLeftSeconds(.63);
			forwardSeconds(.12);
			motor[FR]=118;
			motor[BR]=118;
			wait(.1);
			clearMotor();
			wait(.5);
			raiseIntakeSeconds(1.3); //pick up cube on crosshair
			backwardSeconds(.3);
			turnLeftSeconds(.18);
			forwardSeconds(.6);
			wait(.5);
			raiseIntakeSeconds(1.2); //Pick up second cube


			//To put on post
			backwardSeconds(.7);
			turnLeftSeconds(1.15);
			backwardSeconds(.5);
			raiseArmTicks(2500);
			forwardSeconds(1.1);
			lowerIntakeSeconds(.3);
			forwardSeconds(.1);
			lowerIntakeSeconds(2);


			//To put on skyrise
			/*backwardSeconds(.5);
			turnRightSeconds(.6);
			backwardSeconds(.4);
			turnRightSeconds(.2);
			raiseArmTicks(1800);
			lowerIntakeSeconds(5);
			*/
		}


//2222222222222222222222222222222222222222222222222222222222222222222222222
//Blue side skyrise
				else if (position>=1000&&position<1520)
		{
			turnRightSeconds(.13);

			backwardSeconds(.6,90);
			raiseArmTicks(1950);
			forwardSeconds(.67,90);
			lowerArmSeconds(.6);
			raiseArmTicks(2300);
			backwardSeconds(.4,90);

			motor[BL]=60;
			motor[FL]=60;
			motor[BR]=-60;
			motor[FR]=-60;
			wait(.7);
			clearMotor();

			forwardSeconds(.2,90);
			lowerArmSeconds(1.5);
			motor[BL]=45;
			motor[FL]=45;
			motor[BR]=45;
			motor[FR]=45;
			motor[leftArm]=118;
			motor[rightArm]=118;
			wait(.3);
			clearMotor();
			raiseArmSeconds(1);
			//backwardSeconds(.15,90);//end of first cube


			motor[BL]=-100;
			motor[FL]=-100;
			wait(.5);
			motor[BL]=-100;
			motor[FL]=-100;
			motor[BR]=100;
			motor[FR]=100;
			wait(.15);
			clearMotor();

			/*
			wait(.2);
			forwardSeconds(.2,90);
			lowerArmSeconds(1);
			raiseArmTicks(2300);
			motor[BR]=-100;
			motor[FR]=-100;
			wait(.75);
			motor[BL]=100;
			motor[FL]=100;
			wait(.2);
			clearMotor();
			forwardSeconds(.25);
			lowerArmSeconds(1);
			raiseArmSeconds(1);
		*/
		}


//33333333333333333333333333333333333333333333333333333333333333333333333333
//Red side cube
    else if(position>=1520&&position<2250)
    {
			backwardSeconds(.33);
			raiseArmSeconds(1);
			lowerIntakeSeconds(1);//Drop Cube on post
			backwardSeconds(.2);
			lowerArmSeconds(1);
			forwardSeconds(.1);
			motor[FL]=118;
			motor[BL]=118;
			wait(.4);
			clearMotor();
			turnRightSeconds(.63);
			forwardSeconds(.12);
			motor[FL]=118;
			motor[BL]=118;
			wait(.1);
			clearMotor();
			wait(.5);
			raiseIntakeSeconds(1.3); //pick up cube on crosshair
			backwardSeconds(.3);
			turnRightSeconds(.18);
			forwardSeconds(.6);
			wait(.5);
			raiseIntakeSeconds(1.2); //Pick up second cube


			//To put on post
			backwardSeconds(.7);
			turnRightSeconds(1.15);
			backwardSeconds(.5);
			raiseArmTicks(2500);
			forwardSeconds(1.1);
			lowerIntakeSeconds(.3);
			forwardSeconds(.1);
			lowerIntakeSeconds(2);


			//To put on skyrise
			/*backwardSeconds(.5);
			turnRightSeconds(.6);
			backwardSeconds(.4);
			turnRightSeconds(.2);
			raiseArmTicks(1800);
			lowerIntakeSeconds(5);
			*/
		}


//444444444444444444444444444444444444444444444444444444444444444444444444444
	  //Red side skyrise
	  else if(position>=2250&&position<3000)
	  {
			turnLeftSeconds(.13);
			turnRightSeconds(.1);
			backwardSeconds(.6,90);
			raiseArmTicks(1950);
			forwardSeconds(.62,90);
			lowerArmSeconds(.6);
			raiseArmTicks(2300);
			backwardSeconds(1,90);

			motor[BL]=-60;
			motor[FL]=-60;
			motor[BR]=60;
			motor[FR]=60;
			wait(.5);
			clearMotor();

			forwardSeconds(.45,90);
			lowerArmSeconds(1.5);
			motor[BL]=-45;
			motor[FL]=-45;
			//motor[BR]=45;
			//motor[FR]=45;
			motor[leftArm]=118;
			motor[rightArm]=118;
			wait(.3);
			clearMotor();
			motor[BL]=-45;
			motor[FL]=-45;
			wait(.5);
			backwardSeconds(.2);
			raiseArmSeconds(1);
			//backwardSeconds(.15,90);//end of first cube


			motor[BR]=-100;
			motor[FR]=-100;
			wait(.5);
			motor[BL]=100;
			motor[FL]=100;
			motor[BR]=-100;
			motor[FR]=-100;
			wait(.15);
			clearMotor();

/*
			wait(.2);
			forwardSeconds(.2,90);
			lowerArmSeconds(1);
			raiseArmTicks(2300);
			motor[BL]=-100;
			motor[FL]=-100;
			wait(.75);
			motor[BR]=100;
			motor[FR]=100;
			wait(.2);
			clearMotor();
			forwardSeconds(.25);
			lowerArmSeconds(1);
			raiseArmSeconds(1);
*/
		}


//55555555555555555555555555555555555555555555555555555555555555
	  //Raise arm up
	  else if(position>=3000)
	  {
	  	raiseArmSeconds(1);
		}
}


task main()
{
	autonomous();
}
