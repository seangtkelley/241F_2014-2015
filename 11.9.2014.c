#pragma config(Sensor, in1,    armP,           sensorPotentiometer)
#pragma config(Sensor, in2,    dial,           sensorPotentiometer)
#pragma config(Sensor, dgtl1,  er,             sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  el,             sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  limitswitch,    sensorTouch)
#pragma config(Sensor, dgtl6,  pn,             sensorDigitalOut)
#pragma config(Motor,  port2,           FR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           FL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BL,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           TRarm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           TLarm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BRarm,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           BLarm,         tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Pre-Autonomous
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
 bStopTasksBetweenModes = true;
}





/////////////////////////////////////////////////////////////////////////////////////////
//
//                                  Functions
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
//----------------------------------------------------------------------------------------
//
//                                    INDEX
//
// drive: gives the controller control of the wheels.
// clearmotor: sets all drivemotors to 0.
// forwardd: Move forward by a certain amount of ticks.
// forwards: Move forward by a duration of time.
// backwardd: Move backward a certain amount of ticks.
// backwards:Move backward a duration of time.
// correctturn: Put a certain amount of degrees and the robot gets the most efficiant way to turn done in ticks.
// turnright: turn right by ticks.
// turnleft: turn left by ticks.
// turnr:turn right for a duration of time.
// turnl:turn left for a duration of time.
// raisearm: raise arm a certain amount of ticks.
// lowlowerarm: lower arm for a duration of time.
// increment: Move the arm to a specified level.
// taketower: for a SPECIFIC location, get a skyrise piece and move back to that location.
// lock: engage the pneumatic lock.
// release: release the pneumatic lock.
//
//
/////////////////////////////////////////////////////////////////////////////////////////





void drive(bool half)
{
		if (half==false)//Check if drive toggles half speed.
		{
			motor[BR] = vexRT[Ch2]; //give drive direct control.
			motor[FR] = vexRT[Ch2];
			motor[BL] = vexRT[Ch3];
			motor[FL] = vexRT[Ch3];
		}
		else if(half ==true)
		{
			motor[BR] = vexRT[Ch2]/3;//give drive control but all motor maxes are a third of their orignal max.
			motor[FR] = vexRT[Ch2]/3;
			motor[BL] = vexRT[Ch3]/3;
			motor[FL] = vexRT[Ch3]/3;
		}
}


void clearmotor()
{
	motor[FR]=0;
	motor[FL]=0;
	motor[BR]=0;
	motor[BL]=0;
}

void forwardd(int ticks)
{

		nMotorEncoder[el]=0;
    while(SensorValue(el)<ticks)
    {
      motor[FL]=118;
    	motor[FR]=118;
    	motor[BL]=118;
    	motor[BR]=118;
    }
  motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}

void forwards(int s)
{
      motor[FL]=118;
    	motor[FR]=118;
    	motor[BL]=118;
    	motor[BR]=118;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}

void backwardd(int ticks)
{

    SensorValue[el] = 0;
    while(SensorValue(el)>-ticks)
    {
    motor[FL]=-118;
		motor[FR]=-118;
		motor[BL]=-118;
		motor[BR]=-118;
    }
	motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}


void backwards(int s)
{
      motor[FL]=-118;
    	motor[FR]=-118;
    	motor[BL]=-118;
    	motor[BR]=-118;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}





//Need to caluclate the number of degreesper tick!!!
void correctturn(int degrees) //add sensor ticks per degrees
{
	//CONVERT DEGREES TO TICKS!!!
		int ticks=degrees*3.44;
    int i=SensorValue( el );//named encoder

    //CHANGE THE 1 LATERRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
    if(1<180)
    {
        while (i < ticks)
        {
            motor[FL]=118;
            motor[BL]=118;
            motor[FR]=-118;
            motor[BR]=-118; //<- need to check how long is 1 tick.
        }
    }
    else
    {
        //subtract amount of ticks in 180 degrees
        int ticks= 1-ticks;
        while (i < ticks)
        {
            motor[FL]=-118;
            motor[BL]=-118;
            motor[FR]=118;
            motor[BR]=118;
        }
    }
}


//285 ticks is about 90 degrees.
void turnright(int ticks)
{
	SensorValue[el]=0;
	while(abs(SensorValue[el])<ticks)
	{
		motor[FL]=118/2;
		motor[BL]=118/2;
		motor[FR]=-118/2;
		motor[BR]=-118/2;
	}
}

void turnleft(int ticks)
{
	SensorValue[er]=0;
	while(abs(SensorValue[er])<ticks)
	{
		motor[FL]=-118/2;
		motor[BL]=-118/2;
		motor[FR]=118/2;
		motor[BR]=118/2;
	}
}


void turnr(float seconds)
{
	motor[FL]=118;
	motor[BL]=118;
	motor[FR]=-118;
	motor[BR]=-118;
	wait(seconds);
	clearmotor();
}
void turnl(float seconds)
{
	motor[FL]=-118;
	motor[BL]=-118;
	motor[FR]=118;
	motor[BR]=118;
	wait(seconds);
	clearmotor();
}


void raisearm(int ticks)
{
	SensorValue[pn] = 0;//release
	while(SensorValue[armP]<ticks)
	{
		motor[TLarm]=118;
		motor[TRarm]=118;
		motor[BLarm]=118;
		motor[BRarm]=118;
	}
	motor[TLarm]=0;
	motor[TRarm]=0;
	motor[BLarm]=0;
	motor[BRarm]=0;
	SensorValue[pn] = 1;//lock
}

void lowerarm(float seconds)
{
			SensorValue[pn]=0;//release
      motor[TRarm]= -118;
			motor[TLarm]= -118;
			motor[BRarm]= -118;
			motor[BLarm]= -118;
   		wait(seconds);
    	motor[TRarm]= -0;
			motor[TLarm]= -0;
			motor[BRarm]= -0;
			motor[BLarm]= -0;
			SensorValue[pn]=1;//lock
}


/*
void lowerarm(int ticks)
{
	while(sensorValue[armP]>ticks)
	{
		motor[TLarm]=-118;
		motor[TRarm]=-118;
		motor[BLarm]=-118;
		motor[BRarm]=-118;
	}
	motor[TLarm]=0;
	motor[TRarm]=0;
	motor[BLarm]=0;
	motor[BRarm]=0;
}
*/

void increment(int lev) //raising the arm to certain levels
{
		int level[]={1500,1685,1965,2235,2615,3030,1270};
    if(SensorValue[armP]<level[lev])
    {
        raisearm(level[lev]);
    }
}

void taketower()
{
				int level[]={1322,1685,1965,2235,2615,3030,1270};
        backward(10);
        increment(level[6]);
        forward(25);
        backward(100);
}





void lock()
{
	SensorValue[pn]=1;
}
void release()
{
	SensorValue[pn]=0;
}


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous
//
//
//	1st position:Blue Cube score
//	2nd position:Blue Skyrise score
//	3rd position:Red Cube score
//	4th position:Red Skyrise score
//
//
/////////////////////////////////////////////////////////////////////////////////////////


void autonomous()  //Programs are chosen by the value of the dial potentiometer.
{

		int position=SensorValue[dial];
		SensorValue(el)=0;
		SensorValue(er)=0;



//11111111111111111111111111111111111111111111111111111111111111111111111111
//Red side block scoring
		if (position>=0&&position<550)
		{
			increment(4);
			turnright(20);
			lowerarm(.15);
			backwardd(300);
			lowerarm(.3);
			turnleft(435);
			forwardd(90);
			increment(5);
			turnright(290);
			backwardd(10);
			forwardd(700);
			increment(5);
			wait(.5);
			backwardd(10);
			forwardd(85);
			lowerarm(.5);
			backwardd(300);
		}



//2222222222222222222222222222222222222222222222222222222222222222222222222
//Red side skyrise scoring
		else if (position>=550&&position<1850)
		{

		}


//33333333333333333333333333333333333333333333333333333333333333333333333333
//Blue side
    else if(position>=1850&&position<3350)
    {

	  }


//444444444444444444444444444444444444444444444444444444444444444444444444444
	  //AUTONOMOUS FOR SCORING BLUE SKYRISE
	  else if(position>=3350&&position<5000)
	  {

		}
}

//BACKUP AUTNOMOUS PROGRAMS



//Knocking a cube off and scoring a single point.
/*
			motor[TRarm]=118;
			motor[TLarm]=118;
			motor[BRarm]=118;
			motor[BLarm]=118;
			wait(1);
			motor[TRarm]=0;
			motor[TLarm]=0;
			motor[BRarm]=0;
			motor[BLarm]=0;
			motor[FL]=118;
			motor[BL]=118;
			motor[FR]=118;
			motor[BR]=118;
			wait(1);
			motor[FL]=0;
			motor[BL]=0;
			motor[FR]=0;
			motor[BR]=0;
*/





/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	bool half=false;
	int buttonToggleState8r = 0;
  int buttonPressed8r = 0;
	int buttonToggleState7l = 0;
  int buttonPressed7l = 0;
	while (true)
{



		if( vexRT[ Btn7L ] == 1 )
  {
      if( ! buttonPressed7l )
      {
      	// change the toggle state
      	buttonToggleState7l = 1 - buttonToggleState7l;

        // Note the button is pressed
        buttonPressed7l = 1;
      }
  }
  else
  {
	  // the button is not pressed
	   buttonPressed7l = 0;
	}


  // Now do something with our toggle flag
  if( buttonToggleState7l )
  {
      half=true;
  }
  else
  {
      half=false;
	}





	if( vexRT[ Btn8R ] == 1 )
  {
      if( ! buttonPressed8r )
      {
      	// change the toggle state
      	buttonToggleState8r = 1 - buttonToggleState8r;

        // Note the button is pressed
        buttonPressed8r = 1;
      }
  }
  else
  {
	  // the button is not pressed
	   buttonPressed8r = 0;
	}


  // Now do something with our toggle flag
  if( buttonToggleState8r )
  {
      lock();
  }
  else
  {
      release();
	}











		drive(half);
		motor[TRarm] = 0;
  	motor[TLarm] = 0;
  	motor[BRarm] = 0;
  	motor[BLarm] = 0;

		while(vexRT[Btn6D] == 1)
		{
			motor[TRarm] = 118;
  		motor[TLarm] = 118;
  		motor[BRarm] = 118;
  		motor[BLarm] = 118;
  		drive(half);
		}

		while(vexRT[Btn5D] == 1)
		{
			motor[TRarm] = -118;
  		motor[TLarm] = -118;
  		motor[BRarm] = -118;
  		motor[BLarm] = -118;
  		drive(half);
		}

		while(vexRT[Btn6U] == 1)
		{
			motor[TRarm] = 118/2;
  		motor[TLarm] = 118/2;
  		motor[BRarm] = 118/2;
  		motor[BLarm] = 118/2;
  		drive(half);
		}
		while(vexRT[Btn5U] == 1)
		{
			motor[TRarm] = -118/2;
  		motor[TLarm] = -118/2;
  		motor[BRarm] = -118/2;
  		motor[BLarm] = -118/2;
  		drive(half);
		}
	}
}




















//Hard coded autonomous

/*
task autonomous()
{
	while(true)
	{
		if(SensorValue[limitswitch] == 1)
		{
			break;
		}
	}
	while(SensorValue[armP] <= 1270)
	{
			motor[TRarm]= 118;
			motor[TLarm]= 118;
			motor[BRarm]= 118;
			motor[BLarm]= 118;
	}
	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;
	SensorValue[f] = 1;

	motor[FL]=118;
  motor[FR]=118;
	motor[BL]=118;
  motor[BR]=118;
  wait10Msec(1000);

  SensorValue[pn] = 0;
  while(SensorValue[armP] <= 1400)
  {
	 	motor[TRarm]= 118;
		motor[TLarm]= 118;
		motor[BRarm]= 118;
		motor[BLarm]= 118;
	}
	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;
	SensorValue[pn] = 1;

	motor[FL]=-90;
  motor[FR]=-90;
	motor[BL]=-90;
  motor[BR]=-90;
  wait10Msec(1000);

  motor[FL]=0;
  motor[FR]=0;
	motor[BL]=0;
  motor[BR]=0;
  wait10Msec(2000);

  SensorValue[pn] = 0;
	motor[TRarm]= -118;
	motor[TLarm]= -118;
	motor[BRarm]= -118;
	motor[BLarm]= -118;
	wait10Msec(1000);

	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;

	while(true)
	{
		if(SensorValue[limitswitch] == 1)
		{
			break;
		}
	}
	while(SensorValue[armP] <= 1270)
	{
			motor[TRarm]= 118;
			motor[TLarm]= 118;
			motor[BRarm]= 118;
			motor[BLarm]= 118;
	}
	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;
	SensorValue[pn] = 1;

	motor[FL]=118;
  motor[FR]=118;
	motor[BL]=118;
  motor[BR]=118;
  wait10Msec(1000);

  SensorValue[pn] = 0;
  while(SensorValue[armP] <= 1750)
  {
	 	motor[TRarm]= 118;
		motor[TLarm]= 118;
		motor[BRarm]= 118;
		motor[BLarm]= 118;
	}
	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;
	SensorValue[pn] = 1;

	motor[FL]=-90;
  motor[FR]=-90;
	motor[BL]=-90;
  motor[BR]=-90;
  wait10Msec(1000);

  motor[FL]=0;
  motor[FR]=0;
	motor[BL]=0;
  motor[BR]=0;
  wait10Msec(2000);

  SensorValue[pn] = 0;
	motor[TRarm]= -118;
	motor[TLarm]= -118;
	motor[BRarm]= -118;
	motor[BLarm]= -118;
	wait10Msec(1000);

	motor[TRarm]= 0;
	motor[TLarm]= 0;
	motor[BRarm]= 0;
	motor[BLarm]= 0;
	wait10Msec(2000);
}

*/
