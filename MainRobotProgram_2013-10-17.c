#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    colorKnob,      sensorPotentiometer)
#pragma config(Sensor, in3,    positionKnob,   sensorPotentiometer)
#pragma config(Sensor, I2C_1,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftArm,       tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           rightArm,      tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           backLeft,      tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port5,           backRight,     tmotorVex393, openLoop, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port6,           rightVacuum,   tmotorVex269, openLoop, reversed)
#pragma config(Motor,  port7,           leftVacuum,    tmotorVex269, openLoop)
#pragma config(Motor,  port8,           rightElevator, tmotorVex269, openLoop)
#pragma config(Motor,  port9,           leftElevator,  tmotorVex269, openLoop, reversed)
/*#pragma config(Motor,  port4,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393, openLoop, reversed)*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"


void forward(float inches);
void backward(float inches);
void rotateLeft(float ticks);
void rotateRight(float ticks);
void lowHeight();
void mediumHeight();
void highHeight();
void spinF();
void spinB();
void spinS();

const float TICKS_PER_INCH = 26.3472;

const int speed = 100;

bool rightRedPosition = true;
bool leftRedPosition = true;
bool rightBluePosition = false;
bool leftBluePosition = true;

bool isHigh = false;
bool isMedium = false;
bool isLow = true;

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){

	if(SensorValue[colorKnob] < 40){
		if(SensorValue[positionKnob] < 40){
			rightBluePosition = true;
		}else{
			leftBluePosition = true;
		}
	}else{
		if(SensorValue[positionKnob] < 40){
			rightRedPosition = true;
		}else{
			leftRedPosition = true;
		}
	}

	if(rightBluePosition){

	}else if(leftBluePosition){

  }else if(rightRedPosition){

  }else if(leftRedPosition){

	}
}

task usercontrol(){

	while (true){

  	if(bVEXNETActive){

  		//motor[frontRight] = vexRT[Ch2];
  		//motor[frontLeft] = vexRT[Ch3];
  		motor[backRight] = vexRT[Ch2];
  		motor[backLeft] = vexRT[Ch3];

    	if(vexRT[Btn7D] == true){
      	 motor[rightVacuum] = 127;
      	 motor[leftVacuum] = 127;
    	}else if(vexRT[Btn7U] == true){
      	 motor[leftVacuum] = -127;
      	 motor[rightVacuum] = -127;
    	}else{
      	motor[rightVacuum] = 0;
      	motor[leftVacuum] = 0;
    	}

    	nMotorEncoder[leftArm] = 0;
    	nMotorEncoder[rightArm] = 0;

    	if(vexRT[Btn8U] == true){
      	//if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        // 	motor[rightArm] = 127/2;
        // 	motor[leftArm] = 127;
      	//}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        //	motor[rightArm] = 127;
        //	motor[leftArm] = 127/2;
      	//}else{
        	motor[rightArm] = 127;
        	motor[leftArm] = 127;
      	//}

    	}else if(vexRT[Btn8D] == true){
      	//if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        //	motor[rightArm] = -10;
        // 	motor[leftArm] = -20;
        //	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        //	motor[rightArm] = -20;
        //	motor[leftArm] = -10;
      	//}else{
        	motor[rightArm] = -20;
        	motor[leftArm] = -20;
      	//}

    	}else{
      	motor[rightArm] = 0;
      	motor[leftArm] = 0;
    	}

    	if(vexRT[Btn7U] == true){
      	//if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        // 	motor[rightArm] = 127/2;
        // 	motor[leftArm] = 127;
      	//}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        //	motor[rightArm] = 127;
        //	motor[leftArm] = 127/2;
      	//}else{
        	motor[rightElevator] = 100;
        	motor[leftElevator] = 100;
      	//}

    	}else if(vexRT[Btn7D] == true){
      	//if(nMotorEncoder(rightArm) > nMotorEncoder(leftArm)){
        //	motor[rightArm] = -10;
        // 	motor[leftArm] = -20;
        //	}else if(nMotorEncoder(rightArm) < nMotorEncoder(leftArm)){
        //	motor[rightArm] = -20;
        //	motor[leftArm] = -10;
      	//}else{
        	motor[rightElevator] = -20;
        	motor[leftElevator] = -20;
      	//}

    	}else{
      	motor[rightElevator] = 0;
      	motor[leftElevator] = 0;
    	}

    	wait10Msec(1);

  	}
	}
}

void spinF(){
  motor[rightVacuum] = 127;
  motor[leftVacuum] = 127;
  wait1Msec(500);
}
void spinB(){
  motor[rightVacuum] = -127;
  motor[leftVacuum] = -127;
  wait1Msec(500);
}
void spinS(){
  motor[rightVacuum] = 0;
  motor[leftVacuum] = 0;
  wait1Msec(500);
}

void forward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
		motor[backRight] = speed;
  	motor[backLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void backward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
  	motor[backRight] = -speed;
  	motor[backLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void rotateLeft(float ticks){

 	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[backRight] = -speed;
  	motor[backLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void rotateRight(float ticks){

 	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[backRight] = speed;
  	motor[backLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void highHeight(){

  if(isLow){
  	isHigh = true;
  	isMedium = false;
  	isLow = false;

  	float ticks = 2000;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}

}

void mediumHeight(){
	if(isLow){
		isHigh = false;
  	isMedium = true;
  	isLow = false;

  	float ticks = 1600;

  	nMotorEncoder[leftArm] = 0;
  	nMotorEncoder[rightArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightArm] = 127;
    	motor[leftArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightArm]);
  	}
	}
}

void lowHeight(){

	motor[rightArm] = -127;
  motor[leftArm] = -127;

  wait1Msec(250);

  motor[rightArm] = 0;
  motor[leftArm] = 0;

}
