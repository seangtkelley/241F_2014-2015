#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    powerExpander,  sensorAnalog)
#pragma config(Sensor, in2,    colorKnob,      sensorPotentiometer)
#pragma config(Sensor, in3,    positionKnob,   sensorPotentiometer)
#pragma config(Sensor, dgtl1,  autonButton,    sensorTouch)
#pragma config(Sensor, I2C_1,  rightArmEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftArmEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  leftDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  rightDriveEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftTopArm,    tmotorVex393, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port2,           rightTopArm,   tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port3,           leftBottomArm, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port4,           rightBottomArm, tmotorVex393, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393, openLoop, encoder, encoderPort, I2C_3, 1000)
#pragma config(Motor,  port6,           backRight,     tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_4, 1000)
#pragma config(Motor,  port7,           rightVacuum,   tmotorVex393, openLoop)
#pragma config(Motor,  port8,           leftVacuum,    tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*#pragma config(Motor,  port4,           frontRight,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           frontLeft,     tmotorVex393, openLoop, reversed)*/

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Vex_Competition_Includes.c"


void forward(float inches);
void backward(float inches);
void rotateLeft(float ticks);
void rotateRight(float ticks);
void lowHeight();
void mediumHeight();
void highHeight();
void spinF();
void spinB();
void spinS();


const float TICKS_PER_INCH = 26.3472;

const int speed = 100;

bool rightRedPosition = false;
bool leftRedPosition = false;
bool rightBluePosition = false;
bool leftBluePosition = false;

bool isHigh = false;
bool isMedium = false;
bool isLow = true;

void pre_auton(){
	bStopTasksBetweenModes = true;
}

task autonomous(){

	while(true){
		if(SensorValue(autonButton) == 1){
			if(SensorValue[colorKnob] < 40){
				if(SensorValue[positionKnob] < 40){
					rightBluePosition = true;
					break;
				}else{
					leftBluePosition = true;
					break;
				}
			}else{
				if(SensorValue[positionKnob] < 40){
					rightRedPosition = true;
					break;
				}else{
					leftRedPosition = true;
					break;
				}
			}
			// DELETE THIS
			//rightBluePosition = true;
			break;
		}
	}

	if(rightBluePosition){
	  highHeight();
	  forward(14);
	  spinB();
	  wait1Msec(500);
	  backward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		forward(28);
	  		wait1Msec(500);
	 	 		backward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
	}else if(leftBluePosition){
	  highHeight();
	  forward(14);
	  spinB();
	  wait1Msec(500);
	  backward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		forward(28);
	  		wait1Msec(500);
	 	 		backward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
  }else if(rightRedPosition){
	  highHeight();
	  forward(14);
	  spinB();
	  wait1Msec(500);
	  backward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		forward(28);
	  		wait1Msec(500);
	 	 		backward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
  }else if(leftRedPosition){
	  highHeight();
	  forward(14);
	  spinB();
	  wait1Msec(500);
	  backward(14);
	  spinS();
	  lowHeight();
	  while(true){
	  	if(SensorValue(autonButton) == 1){
	 			highHeight();
	  		forward(28);
	  		wait1Msec(500);
	 	 		backward(28);
	  		lowHeight();
	  		break;
	   	}
	  }
	}
}

task usercontrol(){

	while (true){

  	if(bVEXNETActive){

  		motor[backRight] = vexRT[Ch2];
  		motor[backLeft] = vexRT[Ch3];

    	if(vexRT[Btn5U] == true){
      	 motor[rightVacuum] = 127;
      	 motor[leftVacuum] = 127;
    	}else if(vexRT[Btn5D]== true){
      	 motor[leftVacuum] = -127;
      	 motor[rightVacuum] = -127;
    	}else{
      	motor[rightVacuum] = 0;
      	motor[leftVacuum] = 0;
    	}

    	nMotorEncoder[leftTopArm] = 0;
    	nMotorEncoder[rightTopArm] = 0;

    	if(vexRT[Btn6U] == true){

      	if(abs(nMotorEncoder(rightTopArm)) > abs(nMotorEncoder(leftTopArm))){
         	motor[rightTopArm] = 100/2;
         	motor[leftTopArm] = 100;
         	motor[rightBottomArm] = 100/2;
          motor[leftBottomArm] = 100;
      	}else if(abs(nMotorEncoder(rightTopArm)) < abs(nMotorEncoder(leftTopArm))){
        	motor[rightTopArm] = 100;
        	motor[leftTopArm] = 100/2;
        	motor[rightBottomArm] = 100;
          motor[leftBottomArm] = 100/2;
      	}else{
        	motor[rightTopArm] = 100;
        	motor[leftTopArm] = 100;
        	motor[rightBottomArm] = 100;
          motor[leftBottomArm] = 100;
        }

    	}else if(vexRT[Btn6D] == true){

      	if(abs(nMotorEncoder(rightTopArm)) > abs(nMotorEncoder(leftTopArm))){
        	motor[rightTopArm] = -100/2;
         	motor[leftTopArm] = -100;
         	motor[rightBottomArm] = -100/2;
          motor[leftBottomArm] = -100;
        	}else if(abs(nMotorEncoder(rightTopArm)) < abs(nMotorEncoder(leftTopArm))){
        	motor[rightTopArm] = -100;
        	motor[leftTopArm] = -100/2;
        	motor[rightBottomArm] = -100;
          motor[leftBottomArm] = -100/2;
      	}else{
        	motor[rightTopArm] = -100;
        	motor[leftTopArm] = -100;
        	motor[rightBottomArm] = -100;
          motor[leftBottomArm] = -100;
      	}

    	}else{
      	motor[rightTopArm] = 0;
      	motor[leftTopArm] = 0;
      	motor[rightBottomArm] = 0;
        motor[leftBottomArm] = 0;
    	}

    	wait10Msec(1);

  	}
	}
}

void spinF(){
  motor[rightVacuum] = 127;
  motor[leftVacuum] = 127;
  wait1Msec(500);
}
void spinB(){
  motor[rightVacuum] = -127;
  motor[leftVacuum] = -127;
  wait1Msec(500);
}
void spinS(){
  motor[rightVacuum] = 0;
  motor[leftVacuum] = 0;
  wait1Msec(500);
}

void forward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches * 4;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
		motor[backRight] = speed;
  	motor[backLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void backward(float inches){

	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;
	float targetTicks = TICKS_PER_INCH * inches * 4;

	while(abs(nMotorEncoder[backLeft]) <= targetTicks && abs(nMotorEncoder[backRight]) <= targetTicks){
  	motor[backRight] = -speed;
  	motor[backLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void rotateLeft(float ticks){

 	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[backRight] = -speed;
  	motor[backLeft] = speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void rotateRight(float ticks){

 	nMotorEncoder[backLeft] = 0;
	nMotorEncoder[backRight] = 0;

	while(abs(nMotorEncoder[backLeft]) <= ticks && abs(nMotorEncoder[backRight]) <= ticks){
		motor[backRight] = speed;
  	motor[backLeft] = -speed;
	}

  motor[backRight] = 0;
  motor[backLeft] = 0;

}

void highHeight(){

  if(isLow){
  	isHigh = true;
  	isMedium = false;
  	isLow = false;

  	float ticks = 105;

  	nMotorEncoder[leftTopArm] = 0;
  	nMotorEncoder[rightTopArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightTopArm] = 127;
    	motor[leftTopArm] = 127;
    	motor[rightBottomArm] = 127;
      motor[leftBottomArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftTopArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightTopArm]);
  	}
	}

}

void mediumHeight(){
	if(isLow){
		isHigh = false;
  	isMedium = true;
  	isLow = false;

  	float ticks = 1600;

  	nMotorEncoder[leftTopArm] = 0;
  	nMotorEncoder[rightTopArm] = 0;

  	int RightEncoderTicks = 0;
  	int LeftEncoderTicks = 0;

  	while(RightEncoderTicks < ticks && LeftEncoderTicks < ticks){
    	motor[rightTopArm] = 127;
    	motor[leftTopArm] = 127;
    	motor[rightBottomArm] = 127;
      motor[leftBottomArm] = 127;

    	wait1Msec(100);

    	RightEncoderTicks = abs(nMotorEncoder[leftTopArm]);
    	LeftEncoderTicks = abs(nMotorEncoder[rightTopArm]);
  	}
	}
}

void lowHeight(){

	isLow = true;

	motor[rightTopArm] = -127;
  motor[leftTopArm] = -127;
  motor[rightBottomArm] = -127;
  motor[leftBottomArm] = -127;

  wait1Msec(250);

  motor[rightTopArm] = 0;
  motor[leftTopArm] = 0;
  motor[rightBottomArm] = 0;
  motor[leftBottomArm] = 0;

}
