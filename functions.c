#pragma config(Sensor, in1,    armp,           sensorPotentiometer)
#pragma config(Sensor, in2,    dial,           sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  encoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  encoderLeft,    sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  encoderIntake,  sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  pnr,            sensorDigitalIn)
#pragma config(Sensor, dgtl8,  pnl,            sensorDigitalIn)
#pragma config(Sensor, dgtl9,  armUltra,       sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armLimit,       sensorTouch)
#pragma config(Motor,  port2,           FR,            tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           BR,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           BL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           FL,            tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           leftArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           rightArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftintake,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rightintake,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                  Functions
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
//----------------------------------------------------------------------------------------
//
//                                    INDEX
//
// drive: gives the controller control of the wheels.
// clearmotor: sets all drivemotors to 0.
// forwardd: Move forward by a certain amount of ticks.
// forwards: Move forward by a duration of time.
// backwardd: Move backward a certain amount of ticks.
// backwards:Move backward a duration of time.
// correctturn: Put a certain amount of degrees and the robot gets the most efficiant way to turn done in ticks.
// turnright: turn right by ticks.
// turnleft: turn left by ticks.
// turnr:turn right for a duration of time.
// turnl:turn left for a duration of time.
// raisearm: raise arm a certain amount of ticks.
// lowerarm: lower arm for a duration of time.
// increment: Move the arm to a specified level.
// raiseintake: Raise the intake to pick up cubes.
// lowerintake: lower the intake to pick up cubes.
//
//
/////////////////////////////////////////////////////////////////////////////////////////

int base=1563
float target=base;
float pGain=.3;
float iGain=.2;
float error=target-SensorValue[armp];
float errorSum=0;
//bottom=1530   top=3700
float turn;
float arm;
float intake;




void drive(bool half)
{

			if (half==false)//Check if drive toggles half speed.
			{
				motor[BR] = vexRT[Ch2]; //give drive direct control.
				motor[FR] = vexRT[Ch2];
				motor[BL] = vexRT[Ch3];
				motor[FL] = vexRT[Ch3];
			}
			else if(half ==true)
			{
				motor[BR] = vexRT[Ch2]/3;//give drive control but all motor maxes are a third of their orignal max.
				motor[FR] = vexRT[Ch2]/3;
				motor[BL] = vexRT[Ch3]/3;
				motor[FL] = vexRT[Ch3]/3;
			}
}


void clearMotor()
{
	motor[FR]=0;
	motor[FL]=0;
	motor[BR]=0;
	motor[BL]=0;
}

void forwardTicks(int ticks, float x = 118)
{
		ticks=ticks;
		SensorValue[encoderLeft]=0;
    while(SensorValue(encoderLeft)<ticks)
    {
      motor[FL]=x;
    	motor[FR]=x;
    	motor[BL]=x;
    	motor[BR]=x;
    }
  motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}

void forwardSeconds(float s,float x=118)
{
      motor[FL]=x;
    	motor[FR]=x;
    	motor[BL]=x;
    	motor[BR]=x;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}

void backwardTicks(int ticks, float x=118)
{
		ticks=ticks;
    nMotorEncoder[encoderLeft] = 0;
    int enctick=SensorValue(encoderLeft);
    while(enctick>-ticks)
    {
    motor[FL]=-x;
		motor[FR]=-x;
		motor[BL]=-x;
		motor[BR]=-x;
    }
	motor[FL]=0;
	motor[FR]=0;
	motor[BL]=0;
	motor[BR]=0;
}


void backwardSeconds(float s, float x=118)
{
      motor[FL]=-x;
    	motor[FR]=-x;
    	motor[BL]=-x;
    	motor[BR]=-x;
    	wait(s);
    	motor[FL]=0;
    	motor[FR]=0;
    	motor[BL]=0;
    	motor[BR]=0;
}

void turnRightDegrees(float degree)
{
	degree=degree*10;
	float first=degree*.8;
	while(abs(SensorValue[gyro]) < first)
	{
      motor[FL]=118;
    	motor[FR]=-118;
    	motor[BL]=118;
    	motor[BR]=-118;
	}
	while(abs(SensorValue[gyro]) < degree)
	{
      motor[FL]=50;
    	motor[FR]=-50;
    	motor[BL]=50;
    	motor[BR]=-50;
	}
      motor[FL]=-5;
    	motor[FR]=5;
    	motor[BL]=-5;
    	motor[BR]=5;
  wait1Msec(250);
  clearMotor();
}




void turnLeftDegrees(float degree)
{
	float first=degree*.8;
	degree=degree*10;
	while(abs(SensorValue[gyro]) < first)
	{
      motor[FL]=-118;
    	motor[FR]=118;
    	motor[BL]=-118;
    	motor[BR]=118;
	}
	while(abs(SensorValue[gyro]) < degree)
	{
      motor[FL]=-50;
    	motor[FR]=50;
    	motor[BL]=-50;
    	motor[BR]=50;
	}
      motor[FL]=5;
    	motor[FR]=-5;
    	motor[BL]=5;
    	motor[BR]=-5;
  wait1Msec(250);
  clearMotor();
}



void turnRightTicks(int ticks)
{
	SensorValue[encoderLeft]=0;
	while(SensorValue[encoderLeft]<ticks)
	{
		motor[FL]=118;
		motor[BL]=118;
		motor[FR]=-118;
		motor[BR]=-118;
	}
}


void turnLeftTicks(int ticks)
{
	SensorValue[encoderLeft]=0;
	while(SensorValue[encoderLeft]<ticks)
	{
		motor[FL]=-118;
		motor[BL]=-118;
		motor[FR]=118;
		motor[BR]=118;
	}
}


void turnRightSeconds(float seconds)
{
	motor[FL]=118;
	motor[BL]=118;
	motor[FR]=-118;
	motor[BR]=-118;
	wait(seconds);
	clearMotor();
}
void turnLeftSeconds(float seconds)
{
	motor[FL]=-118;
	motor[BL]=-118;
	motor[FR]=118;
	motor[BR]=118;
	wait(seconds);
	clearMotor();
}


void raiseArmTicks(int ticks)
{
	while(SensorValue[armp]<ticks)
	{
		motor[leftArm]=118;
		motor[rightArm]=118;
	}
	motor[leftArm]=0;
	motor[rightArm]=0;
}


void raiseArmSeconds(float s)
{
		motor[leftArm]=118;
		motor[rightArm]=118;
		wait(s);
		motor[leftArm]=0;
		motor[rightArm]=0;
}



void lowerArmTicks(int ticks)
{
	while(SensorValue[armp]>ticks)
	{
		motor[leftArm]=-118;
		motor[rightArm]=-118;

	}
	motor[leftArm]=0;
	motor[rightArm]=0;
}



void lowerArmSeconds(float seconds)
{
      motor[leftArm]= -118;
			motor[rightArm]= -118;
   		wait(seconds);
    	motor[leftArm]= -0;
			motor[rightArm]= -0;
}


void raiseIntakeSeconds(float s)
{

	motor[leftintake]=-118;
	motor[rightintake]=-118;
	wait(s);
	motor[leftintake]=0;
	motor[rightintake]=0;
}


void lowerIntakeSeconds(float s)
{
	motor[leftintake]=118;
	motor[rightintake]=118;
	wait(s);
	motor[leftintake]=0;
	motor[rightintake]=0;
}


void retrieve()
{
	raiseArmTicks(1950);
	while(SensorValue[armUltra])
	{
		motor[FL]=-80;
		motor[BL]=-80;
		motor[FR]=80;
		motor[FR]=80;
	}
	turnRightSeconds(.04,80);
}






task armcontrol()
{
	while(true)
	{
		error=target-SensorValue[armp];
		errorSum+=error;
		motor[leftArm]= error*pGain+errorSum*iGain;
		motor[rightArm]= error*pGain+errorSum*iGain;
	}
}
