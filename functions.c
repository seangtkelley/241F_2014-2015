#pragma config(Sensor, in1,    armp,           sensorPotentiometer)
#pragma config(Sensor, in2,    dial,           sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    acc,            sensorAccelerometer)
#pragma config(Sensor, dgtl1,  pnintake,       sensorDigitalOut)
#pragma config(Sensor, dgtl2,  pnsky,          sensorDigitalOut)
#pragma config(Motor,  port2,           BL,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           ML,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           FL,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           BR,            tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           MR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           FR,            tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           rightArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftArm,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                  Functions
//
// This file contains functions used by both the autonomous and competition files
//
//----------------------------------------------------------------------------------------
//
//                                    INDEX
//
//  drive:--------------Gives drive control to vexnet controller.
//  clearMotor:---------Sets motor values to 0.
//  fullStop:-----------Completely stops all motors without drift.
//  forwardTicks:-------Moves bot forward a given tick amount.
//  backwardTicks:------Moves bot backwards a given amount of ticks.
//  forwardSeconds:-----Moves bot forward a given amount of seconds.
//  backwardSeconds:----Moves bot backwards a given amount of seconds.
//  turnRightDegrees:---Turn bot right a certain amount of degrees.
//  turnLeftDegrees:----Turn bot left a certain amount of degrees.
//  turnRightTicks:-----Turn bot right a certain amount of ticks.
//  turnLeftTicks:------Turn bot left a certain amount of ticks.
//  turnRightSeconds:---Turn bot right a certain amount of seconds.
//  turnLeftSeconds:----Turn bot left a certain amount of seconds.
//  raiseArmTicks:------Raises arm a given amount of ticks.
//  lowerArmTicks:------Lowers arm a given amount of ticks.
//  raiseArmSeconds:----Raises arm a given amount of seconds.
//  lowerArmSeconds:----Lowers arm a given amount of seconds.
//
//  WORKS IN PROGRESS
//
//  Armcontrol:---------Keeps arm at a constant height.
//
/////////////////////////////////////////////////////////////////////////////////////////

// Global variables
string consoleCache = "";
float pos = 0;
float vel = 0;
float accel = 0;


/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 DRIVETRAIN
//
/////////////////////////////////////////////////////////////////////////////////////////

/**
* @void drive
*
* @desc gives drive control to VexNET controller
*
* @args  half boolean  determines if motors should be running at half speed
*/
void drive(bool half)
{

			if (half==false)//Check if drive toggles half speed.
			{
				motor[BR] = vexRT[Ch2]; //give drive direct control.
				motor[FR] = vexRT[Ch2];
				motor[BL] = vexRT[Ch3];
				motor[FL] = vexRT[Ch3];
			}
			else if(half ==true)
			{
				motor[BR] = vexRT[Ch2]/3;//give drive control but all motor maxes are a third of their orignal max.
				motor[FR] = vexRT[Ch2]/3;
				motor[BL] = vexRT[Ch3]/3;
				motor[FL] = vexRT[Ch3]/3;
			}
}


/**
* @void clearMotor
*
* @desc clears all the motors
*
* @args  N/A
*/
void clearMotor()
{
	motor[FR]=0;
	motor[MR]=0;
	motor[BR]=0;
	motor[FL]=0;
	motor[ML]=0;
	motor[BL]=0;
}

/**
* @void motorcheck
*
* @desc runs each motor for 1.5 seconds
*
* @args  N/A
*/
void motorcheck()
{
	motor[FR]=118;
	wait(1.5);
	clearMotor();
	motor[MR]=118;
	wait(1.5);
	clearMotor();
	motor[BR]=118;
	wait(1.5);
	clearMotor();
	motor[FL]=118;
	wait(1.5);
	clearMotor();
	motor[ML]=118;
	wait(1.5);
	clearMotor();
	motor[BL]=118;
	wait(1.5);
	clearMotor();
}

/**
* @void fullStop
*
* @desc completely stops all motors without drift
*
* @args  N/A
*/
void fullStop(int x=118,int direction=0, bool fancy=false)
{
	if(fancy)
	{
		if(direction==1)
		{
			int FR = x;
			int FL = 0;
			int BR = x;
			int BL = 0;
			motor[FR]=FR*-.1;
			motor[FL]=FL*-.1;
			motor[BR]=BR*-.1;
			motor[BL]=BL*-.1;
			wait1Msec(150);
			clearMotor();
		}
		else if(direction==2)
		{
			int FR = 0;
			int FL = x;
			int BR = 0;
			int BL = x;
			motor[FR]=FR*-.1;
			motor[FL]=FL*-.1;
			motor[BR]=BR*-.1;
			motor[BL]=BL*-.1;
			wait1Msec(150);
			clearMotor();
		}
	}
	else
	{
		if(direction==1)
		{
			int FR = x;
			int FL = -x;
			int BR = x;
			int BL = -x;
			motor[FR]=FR*-.1;
			motor[FL]=FL*-.1;
			motor[BR]=BR*-.1;
			motor[BL]=BL*-.1;
			wait1Msec(150);
			clearMotor();
		}
		else if(direction==2)
		{
			int FR = -x;
			int FL = x;
			int BR = -x;
			int BL = x;
			motor[FR]=FR*-.1;
			motor[FL]=FL*-.1;
			motor[BR]=BR*-.1;
			motor[BL]=BL*-.1;
			wait1Msec(150);
			clearMotor();
		}
		else
		{
			int FR = x;
			int FL = x;
			int BR = x;
			int BL = x;
			motor[FR]=FR*-.1;
			motor[FL]=FL*-.1;
			motor[BR]=BR*-.1;
			motor[BL]=BL*-.1;
			wait1Msec(150);
			clearMotor();
		}
	}
}



/**
* @void forwardSeconds
*
* @desc moves bot forward for a given amount of seconds
*
* @args  s  int    amount of seconds to move forward
				 x  float  speed of motors
*/
void forwardSeconds(float s,float x=118)
{
  motor[FL]=x;
	motor[FR]=x;
	motor[BL]=x;
	motor[BR]=x;
	wait1Msec(s*1000);
	fullStop(x);
}

/**
* @void backwardSeconds
*
* @desc moves bot backwards for a given amount of seconds
*
* @args  s  int    amount of seconds to move forward
*				 x  float  speed of motors
*/
void backwardSeconds(float s, float x=118)
{
  motor[FL]=-x;
	motor[FR]=-x;
	motor[BL]=-x;
	motor[BR]=-x;
	wait1Msec(s*1000);
	fullStop(x);
}

/**
* @task lockLeftSide
*
* @desc locks left side motors with PI loop
*
* @args  N/A
*/
/*
task lockLeftSide()
{
	float target = 0;
	float pGain = .3;
	float iGain = .02;
	float error = target-SensorValue[encoderLeft];
	float errorSum=0;

	while(true){
		error=target-SensorValue[encoderLeft];
		errorSum+=error;

		motor[FL] = error*pGain+errorSum*iGain;
		  motor[BL] = error*pGain+errorSum*iGain;
	}
}
*/
/**
* @task lockRightSide
*
* @desc locks right side motors with PI loop
*
* @args  N/A
*/
/*
task lockRightSide()
{
	float target = 0;
	float pGain = .3;
	float iGain = .02;
	float error = target-SensorValue[encoderRight];
	float errorSum=0;

	while(true){
		error=target-SensorValue[encoderRight];
		errorSum+=error;

		motor[FR] = error*pGain+errorSum*iGain;
	  motor[BR] = error*pGain+errorSum*iGain;
	}
}
*/
/**
* @void fancyTurnRightDegrees
*
* @desc turns bot right only using left side motors
*
* @args  degrees   int     amount of degrees to turn right
*        forward   bool    boolean if bot is turning forward or backward
*        x         int     speed of motors
*/
void fancyTurnRightDegrees(int degrees, bool forward=true, int x=80)
{
	// reset encoders
	degrees=degrees*10;
	// reset gyro
	SensorValue[gyro]=0;

	// lock the right side motors
	//startTask(lockRightSide);

	// turn forwards or backwards based on forward boolean
	if(forward)
	{
		while(abs(SensorValue[gyro]) < degrees)
		{
			motor[FL] = x;
		  motor[BL] = x;
		}
		motor[FL] = -10;
		motor[BL] = -10;
		wait1Msec(150);
		motor[FL] = 0;
		motor[BL] = 0;
	}
	else
	{
		while(abs(SensorValue[gyro]) < degrees)
		{
			motor[FL] = -x;
		  motor[BL] = -x;
		}
		motor[FL] = 10;
	  motor[BL] = 10;
	  wait1Msec(150);
	  motor[FL] = 0;
	  motor[BL] = 0;
	}

	// unlock the right side motors
	//stopTask(lockRightSide);
}

/**
* @void fancyTurnLeftDegrees
*
* @desc turns bot left only using left side motors
*
* @args  degrees   int     amount of degrees to turn left
*        forward   bool    boolean if bot is turning forward or backward
*        x         int     speed of motors
*/
void fancyTurnLeftDegrees(int degrees, bool forward=true, int x=80)
{
	// reset encoders
	degrees=degrees*10;
	// reset gyro
	SensorValue[gyro] = 0;

	// lock the left side motors
	//startTask(lockLeftSide);

	// turn forwards or backwards based on forward boolean
	if(forward)
	{
		while(abs(SensorValue[gyro]) < degrees)
		{
			motor[FR] = x;
		  motor[BR] = x;
		}
		motor[FR] = -10;
		motor[BR] = -10;
		wait1Msec(150);
		motor[FR] = 0;
		motor[BR] = 0;
	}
	else
	{
		while(abs(SensorValue[gyro]) < degrees)
		{
			motor[FR] = -x;
		  motor[BR] = -x;
		}
		motor[FR] = 10;
		motor[BR] = 10;
		wait1Msec(150);
		motor[FR] = 0;
		motor[BR] = 0;
	}
// unlock the left side motors
//stopTask(lockLeftSide);
}






/**
* @void turnRightDegrees
*
* @desc turns bot right a given amount of degrees
*
* @args  degree  int    amount of degrees to turn right
*				 x       float  speed of motors
*/
void turnRightDegrees(float degree, float x=90)
{
	SensorValue[gyro]=0;
	degree=degree*10;
	float first=degree*.6;



	while(abs(SensorValue[gyro]) < first)
	{
		/*if( abs(SensorValue[encoderLeft]) >= abs(SensorValue[encoderRight])+5 ){
			motor[FL]=x*.8;
    	motor[FR]=-x;
    	motor[BL]=x*.8;
    	motor[BR]=-x;
		} else if( abs(SensorValue[encoderRight]) >= abs(SensorValue[encoderLeft])+5 ){
			motor[FL]=x;
    	motor[FR]=-x*.8;
    	motor[BL]=x;
    	motor[BR]=-x*.8;
		} else {*/
			motor[FL]=x;
    	motor[FR]=-x;
    	motor[BL]=x;
    	motor[BR]=-x;
		//}
	}
	while(abs(SensorValue[gyro]) <degree)
	{
		if(x*.35<40)
		{
			motor[FL]=40;
    	motor[FR]=-40;
    	motor[BL]=40;
    	motor[BR]=-40;
		}
		else
		{
			/*if( abs(SensorValue[encoderLeft]) >= abs(SensorValue[encoderRight])+5 ){
				motor[FL]=x*.4*.8;
	    	motor[FR]=-x*.4;
	    	motor[BL]=x*.4*.8;
	    	motor[BR]=-x*.4;
			} else if( abs(SensorValue[encoderRight]) >= abs(SensorValue[encoderLeft])+5 ){
				motor[FL]=x*.4;
	    	motor[FR]=-x*.4*.8;
	    	motor[BL]=x*.4;
	    	motor[BR]=-x*.4*.8;
			} else {*/
				motor[FL]=x*.35;
	    	motor[FR]=-x*.35;
	    	motor[BL]=x*.35;
	    	motor[BR]=-x*.35;
			//}
    }
	}
  fullStop();
}


/**
* @void turnLeftDegrees
*
* @desc turns bot left a given amount of degrees
*
* @args  degree  int    amount of degrees to turn left
*				 x       float  speed of motors
*/
void turnLeftDegrees(float degree, float x=90)
{
	SensorValue[gyro]=0;
	degree=degree*10;
	float first=degree*.6;




	while(abs(SensorValue[gyro]) < first)
	{
			/*if( abs(SensorValue[encoderLeft]) >= abs(SensorValue[encoderRight])+5 ){
				motor[FL]=-x*.8;
	    	motor[FR]=x;
	    	motor[BL]=-x*.8;
	    	motor[BR]=x;
			} else if( abs(SensorValue[encoderRight]) >= abs(SensorValue[encoderLeft])+5 ){
				motor[FL]=-x;
	    	motor[FR]=x*.8;
	    	motor[BL]=-x;
	    	motor[BR]=x*.8;
			} else {*/
				motor[FL]=-x;
	    	motor[FR]=x;
	    	motor[BL]=-x;
	    	motor[BR]=x;
			//}
	}
	while(abs(SensorValue[gyro]) < degree)
	{
		if(x*.35<40)
		{
			motor[FL]=-40;
    	motor[FR]=40;
    	motor[BL]=-40;
    	motor[BR]=40;
		}
		else
		{
			/*if( abs(SensorValue[encoderLeft]) >= abs(SensorValue[encoderRight])+5 ){
				motor[FL]=-x*.4*.8;
	    	motor[FR]=x*.4;
	    	motor[BL]=-x*.4*.8;
	    	motor[BR]=x*.4;
			} else if( abs(SensorValue[encoderRight]) >= abs(SensorValue[encoderLeft])+5 ){
				motor[FL]=-x*.4;
	    	motor[FR]=x*.4*.8;
	    	motor[BL]=-x*.4;
	    	motor[BR]=x*.4*.8;
			} else {*/
				motor[FL]=-x*.35;
	    	motor[FR]=x*.35;
	    	motor[BL]=-x*.35;
	    	motor[BR]=x*.35;
			//}
    }
	}
  fullStop();
}


/**
* @void turnRightSeconds
*
* @desc turns bot right a given amount of seconds
*
* @args  seconds   int    amount of seconds to turn right
*				 x         float  speed of motors
*/
void turnRightSeconds(float seconds, float x=118)
{
	motor[FL]=x;
	motor[BL]=x;
	motor[FR]=-x;
	motor[BR]=-x;
	wait1Msec(seconds*1000);
	fullStop();
}

/**
* @void turnLeftSeconds
*
* @desc turns bot left a given amount of seconds
*
* @args  seconds   int    amount of seconds to turn left
*				 x         float  speed of motors
*/
void turnLeftSeconds(float seconds, float x=118)
{
	motor[FL]=-x;
	motor[BL]=-x;
	motor[FR]=x;
	motor[BR]=x;
	wait1Msec(seconds*1000);
	fullStop();
}



/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 ARM
//
/////////////////////////////////////////////////////////////////////////////////////////



/**
* @void raiseArmTicks
*
* @desc raises arm a given amount of ticks
*
* @args  ticks   int    amount of ticks to raise arm
*				 x       float  speed of motors
*/
void raiseArmTicks(int ticks,float x=118)
{
	while(SensorValue[armp]<ticks)
	{
		motor[leftarm]=x;
		motor[rightarm]=x;
	}
	motor[leftarm]=0;
	motor[rightarm]=0;
}

/**
* @void lowerArmTicks
*
* @desc lowers arm a given amount of ticks
*
* @args  ticks   int    amount of ticks to lower arm
*				 x       float  speed of motors
*/
void lowerArmTicks(int ticks,float x=118)
{
	while(SensorValue[armp]>ticks)
	{
		motor[leftarm]=-x;
		motor[rightarm]=-x;
	}
	motor[leftarm]=0;
	motor[rightarm]=0;
}

/**
* @void raiseArmSeconds
*
* @desc raises arm a given amount of seconds
*
* @args  s   int    amount of seconds to raise arm
*				 x   float  speed of motors
*/
void raiseArmSeconds(float s, float x=118)
{
	motor[leftarm]=x;
	motor[rightarm]=x;
	wait1Msec(s*1000);
	motor[leftarm]=0;
	motor[rightarm]=0;
}


/**
* @void lowerArmSeconds
*
* @desc lowers arm a given amount of seconds
*
* @args  s   int    amount of seconds to raise arm
*				 x   float  speed of motors
*/
void lowerArmSeconds(float seconds, float x=118)
{
  motor[leftarm]= -x;
	motor[rightarm]= -x;
	wait1Msec(seconds*1000);
	motor[leftarm]= 0;
	motor[rightarm]= 0;
}

/**
* @void opencube
*
* @desc opens cube intake
*
* @args  NONE
*
*/

void opencube()
{
	SensorValue[pnintake]=1;
}

/**
* @void closecube
*
* @desc closes cube intake
*
* @args  NONE
*
*/

void closecube()
{
	SensorValue[pnintake]=0;
}

/**
* @void opensky
*
* @desc opens skyrise intake
*
* @args  NONE
*
*/

void opensky()
{
	SensorValue[pnsky]=1;
}

/**
* @void closesky
*
* @desc closes skyrise intake
*
* @args  NONE
*
*/

void closesky()
{
	SensorValue[pnsky]=0;
}

/**
* @void openintake
*
* @desc opens intake
*
* @args  NONE
*
*/

void openintake()
{
	SensorValue[pnintake]=1;
}

/**
* @void closesky
*
* @desc closes intake
*
* @args  NONE
*
*/

void closeintake()
{
	SensorValue[pnintake]=0;
}

/**
* @task armcontrol
*
* @desc raises or lowers arm to certain point
*       using PI loop
*
* @args target float tick value target for arm
*/
/*
task armcontroller()
{
	while (true)
	{
		int constant=.95;
		float proportion= SensorValue[armp]/target;
		float error=target-SensorValue[armp];
		if(error<0)
		{
			motor[leftarm]= -118*(exp( proportion * log(constant))) ;
			motor[rightarm]= -118*(exp( proportion * log(constant)));
		}
		else
		{
			motor[leftarm]= 118*(exp( proportion * log(constant)));
			motor[rightarm]= 118*(exp( proportion * log(constant)));
		}
	}
}
*/
/**
* @void println
*
* @desc prints string to LCD screen
*
* @args str string string to display to LCD screen
*/
void println(string str)
{
	clearLCDLine(0);
	clearLCDLine(1);

	displayLCDString(0, 0, consoleCache);
	displayLCDString(0, 0, str);

	consoleCache = str;

}

/**
* @task updatePos
*
* @desc updates the position, velocity, acceleration
				of the robot
*
* @args NONE
*/
/*task updatePos()
{
	float accelRatio = 0;
	float yPos = 0;
	float yVel = 0;
	float yAccel = 0;
	float posAt1MSec = 0;
	float errorFactor = 1.1667;

	int zYDif = 0;
	int originalY = 0;

	task yPosition(){
	  while(true){
	    wait1Msec(1);//1 millisecond sampling time
	    yAccel = (abs(SensorValue[yAxis] - originalY)) > 2 ? (SensorValue[yAxis] - originalY) / accelRatio : 0;
	    //check if threshold is passed and set "instantanious" acceleration
	    yVel += (yAccel / 1000);//update "instantainious" velocity
	    yPos += (yVel / 1000);//update position
	  }
	}
}*/
